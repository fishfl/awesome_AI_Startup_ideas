{
    "id": "2509.04159",
    "title": "Towards an Action-Centric Ontology for Cooking Procedures Using Temporal Graphs",
    "summary": "This article proposes a domain-specific language for an extended domain, representing recipes as directed action graphs to capture the workflow, transitions, environment, concurrency, and compositional structure in cooking processes. This provides an accurate and modular modeling for complex cooking workflows.",
    "abstract": "Formalizing cooking procedures remains a challenging task due to their inherent complexity and ambiguity. We introduce an extensible domain-specific language for representing recipes as directed action graphs, capturing processes, transfers, environments, concurrency, and compositional structure. Our approach enables precise, modular modeling of complex culinary workflows. Initial manual evaluation on a full English breakfast recipe demonstrates the DSL's expressiveness and suitability for future automated recipe analysis and execution. This work represents initial steps towards an action-centric ontology for cooking, using temporal graphs to enable structured machine understanding, precise interpretation, and scalable automation of culinary processes - both in home kitchens and professional culinary settings.",
    "category1": "Application Implementation",
    "category2": "Personal Tools",
    "category3": "Multi-Agent",
    "authors": "Aarush Kumbhakern,Saransh Kumar Gupta,Lipika Dey,Partha Pratim Das",
    "subjects": [
        "Artificial Intelligence (cs.AI)",
        "Computation and Language (cs.CL)"
    ],
    "comments": "Comments:6 pages, 3 figures, 1 table, 11 references, ACM International Conference on Multimedia 2025 - Multi-modal Food Computing Workshop",
    "keypoint": "- The paper introduces an extensible domain-specific language (DSL) for representing recipes as directed action graphs.\n- Recipes are modeled using three atomic operations: Process, Transfer, and Plate.\n- Actions are parameterized by entities such as environment, tools, techniques, temperature profiles, and temporal constraints.\n- Intermediate action outputs, called partially processed components (PPCs), remain implicit but are fully traceable.\n- Concurrency is modeled via branching with partial-order and relative-timing constraints.\n- Environments are modeled as (container, location, optional geometry) tuples to support spatial operations and dynamic reassignment.\n- The framework supports simulation, robotic execution, automated instruction generation, and hybrid symbolic‚Äìneural reasoning.\n- A manual evaluation on a full English breakfast recipe demonstrates the DSL's expressiveness and suitability for automated analysis.\n- The DSL outperforms existing formalisms in coverage of procedural cooking semantics, scoring 72.4% on a 29-item feature checklist.\n- The DSL natively supports concurrency, environment lineage, relative timing, temperature ramps, and observational termination conditions.\n- Future work includes building a large-scale pipeline using LLMs and NLP to convert natural-language recipes into structured action graphs.\n- The proposed pipeline includes simplification, standardization, parsing, and implicit step recovery modules.\n- The work aims to advance computational gastronomy and intelligent kitchen technologies through formal modeling of culinary processes.",
    "date": "2025-09-07",
    "paper": "Towards an Action-Centric Ontology for Cooking Procedures\nUsing Temporal Graphs\nAarush Kumbhakern‚àó‚Ä†\nSaransh Kumar Gupta‚àó‚Ä†\nLipika Dey‚Ä†\nPartha Pratim Das\naarush.kumbhakern_ug25@ashoka.edu.in\nsaransh.gupta@ashoka.edu.in\nlipika.dey@ashoka.edu.in\npartha.das@ashoka.edu.in\nAshoka University\nSonepat, Haryana, India\nAbstract\nFormalizing cooking procedures remains a challenging task due to\ntheir inherent complexity and ambiguity. We introduce an extensi-\nble domain-specific language for representing recipes as directed\naction graphs, capturing processes, transfers, environments, concur-\nrency, and compositional structure. Our approach enables precise,\nmodular modeling of complex culinary workflows. Initial manual\nevaluation on a full English breakfast recipe demonstrates the DSL‚Äôs\nexpressiveness and suitability for future automated recipe analy-\nsis and execution. This work represents initial steps towards an\naction-centric ontology for cooking, using temporal graphs to en-\nable structured machine understanding, precise interpretation, and\nscalable automation of culinary processes - both in home kitchens\nand professional culinary settings.\nKeywords\nFood Computing, Domain-specific Languages, Recipe Formaliza-\ntion, Semantic Modeling, Action-Graphs\n1\nIntroduction\nRecipes are ubiquitous procedural texts that describe multi-step\ntransformations from raw ingredients to finished products. They\ninterleave sequential and concurrent actions, environment changes,\nand domain-specific techniques, yet their apparent simplicity hides\nchallenges for computation: ambiguous language, implicit context,\nand variable inputs/goals. Structured representations now underpin\napplications from automated cooking and robotic preparation to\nculinary knowledge bases and nutritional analysis. However, many\nexisting formalisms lack the rigor, modular extensibility, or seman-\ntic precision needed for fine-grained reasoning about physical and\ntemporal dynamics. Treating recipes as linear action lists often\nobscures state transitions, concurrency, spatial manipulation, and\ncontext-sensitive environmental effects.\nWe propose an early-stage framework that represents recipes\nas action graphs built from three atomic operations - Process,\nTransfer, and Plate - encoding cooking as a directed acyclic\ngraph (DAG) of food-state and spatial transformations. Actions are\n‚àóThese authors contributed equally.\n‚Ä†Corresponding Authors\nparameterized by entities such as environment, tools, techniques,\ntemperature profiles, and temporal constraints. Intermediate action\noutputs (partially processed components, PPCs) remain implicit,\nand feed directly into other actions without explicit extraction\ninto nodes to keep graphs compact; full provenance is recoverable\nby traversing the local subgraph at each point of use. The frame-\nwork natively models concurrency via branching with partial-order\nand relative-timing constraints, enabling interleaved actions (e.g.\nstirring while heating, adding an ingredient mid-process). Envi-\nronments are explicit (and implicit, when associated with PPCs)\ncontext configurations supporting dynamic reassignment and spa-\ntial operations (e.g. tilting a pan to control spread/coverage).\nThe framework lays a foundation for simulation, robotic execu-\ntion, automated instruction generation, and hybrid symbolic‚Äìneural\nreasoning. This paper details the design rationale, formal constructs,\nand representational choices of the action-graph grammar, outlines\nnext steps toward large-scale parsing and execution, and offers\na compact, extensible substrate for intelligent cooking systems,\nrecipe understanding, and computational gastronomy.\n2\nRelated Work\nEarly formalizations treated recipes as ordered imperative lists\nmapped to first-order action languages. MILK [10], introduced with\nthe CURD corpus, encodes each instruction with a compact set of\ntyped predicates (e.g. combine, cut, serve) and tracks ingredient/tool\nstate via creation/deletion. Despite showing (relatively) broad cov-\nerage, only ‚âà300 recipes were annotated and automatic parsing\naccuracy was low, limiting downstream use.\nSubsequent work sought richer structure from text. Flow Graphs\n[6] connect ingredients, tools, and actions with typed edges (200\nannotated Japanese recipes) but conflate temporal and causal links\nand provide no released parser. Ingredient‚ÄìInstruction Dependency\nTrees [4] attempt to extract the structure of recipes into an ‚ÄúIngredi-\nent Merging Map‚Äù, achieving 93% accuracy on 260 English recipes;\nhowever, ingredient state, environment, and concurrency are out\nof scope. Large-scale information-extraction pipelines pair NER\nwith dependency-based relation extraction to normalize ingredients\nand link techniques, utensils, and items [3]. Systems that induce\narXiv:2509.04159v1  [cs.AI]  4 Sep 2025\nKumbhakern et al.\nreduced action tuples/graphs from instructions via NER + SRL like-\nwise report persistent errors with coreference and with unstated or\nimplicitly chosen tools/containers [1].\nTo evaluate procedural competence, Nevens et al. [7] map recipes\nto 38 executable kitchen actions and execute them in qualitative and\nquantitative simulators; their semantic language tracks environ-\nment state and parameters, but a single gold plan per recipe penal-\nizes valid alternatives. Emerging latent program approaches jointly\nlearn image/recipe/program embeddings [8] or mine sentence-level\ntrees for generation/retrieval [11], yet the induced programs remain\nopaque sequences lacking explicit environment transfers, collaps-\ning intermediate states, and omitting concurrency.\nAuthoring-oriented DSLs emphasize metadata and validation.\nCorel [9] types ingredients, tools, time, temperature, and nutrition\nand compiles to web pages, but omits environment tracking and\ntime-relative processes.\nAcross these threads, gaps remain in (i) unifying state-altering\nand spatial transfers with environment lineage, (ii) representing\npartial products without graph bloat while retaining provenance,\nand (iii) expressing concurrent/interleaved actions with machine-\ncheckable constraints. Our Recipe Action-Graph DSL addresses\nthese: it separates Process (state change) from Transfer (spatial\nchange) and binds every ingredient/PPC to an explicit environment\nlineage; keeps PPCs implicit yet fully traceable via backward tra-\nversal; and treats concurrency as first-class with merge semantics\nand relative-timing/interjection capabilities. A proposed technique\nlexicon with defaults and post-conditions ensures semantic consis-\ntency, and the graph supports multiple, equivalently valid execution\nplans.\n3\nMethodology and Design\nThe Recipe Action-Graph DSL encodes recipes as DAGs of pa-\nrameterized action nodes, rather than as linear scripts. Nodes de-\nnote composable actions that transform inputs; edges capture both\nmaterial flow and partial-order (relative-timing) constraints. The\nontology that the DSL presupposes comprises three action types\n- Process, Transfer, and Plate - and the entity types Ingredi-\nents, Environments, and PPCs. Actions enact explicit state changes\nand environment-aware transfers, carrying raw inputs forward to\nPlate-ready outputs.\nGraph compilation and semantics. The DSL compiles to a DAG in\nwhich nodes represent actions and ingredients, while edges encode\ndependency relations. This structure permits multiple valid exe-\ncution orderings (consistent with partial-order constraints) while\npreserving temporal precedence and maintaining ingredient prove-\nnance. Traceability is supported in both directions: from named\nraw ingredients to final dish components and from any point of\nuse back to its sources.\nIngredients. Ingredients follow a structured schema: name, quan-\ntity, unit, and optional form and modifiers. Only named ingredients\nserve as graph roots; all subsequent transformations flow from\nthese initial entities.\nEnvironments. Every item in the system (ingredient or PPC) may\nbe associated with an environment, modeled as a tuple - (container,\nlocation, optional geometry) - where geometry captures pose\nor orientation (e.g. tilt angle). This makes explicit not only what\nis acted upon, but also where and how it is situated - a critical\ndeterminant of culinary outcomes.\n(Modifiers\ndescribes\n‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíTechnique\napplied to\n‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚ÜíItem\nusing\n‚àí‚àí‚àí‚àí‚ÜíTool)\nat\n‚àí‚Üí\nTemperature\nuntil\n‚àí‚àí‚àí‚àí‚ÜíTime Elapsed / Outcome Achieved\nFigure 1: Generalized high-level characterization of cooking\nprocesses.\nAction types.\n‚Ä¢ Process nodes encode changes to physical/chemical state,\nparameterized by an input (either an Ingredient or a PPC),\ntechnique, tool, temperature specification (with ramp/curve\nsupport), time/duration, completion conditions, and modi-\nfiers. The technique parameter is a reference to an object\nentry in a formalized culinary technique lexicon, containing\na standardized static and optional parametrized definition\n(see Future Work). Each process step can include rich sen-\nsory and outcome-based termination conditions - such as\ndoneness, texture, color, or aroma - allowing for flexible,\nyet grounded reasoning about process completion.\n‚Ä¢ Transfer nodes encode source ‚Üídestination environment\nreassignment of an Ingredient or PPC between environ-\nments (e.g. to a pan, oven, or fridge). Each transfer updates\nthe subsequent PPC‚Äôs associated environment for all sub-\nsequent actions, modeling context-driven state changes\n(implying that a Transfer can then occur from one PPC to\nanother, with the PPC produced by the transfer inheriting\nthe environment of the target PPC).\n‚Ä¢ Plate nodes are reserved for final touches - pure assembly\nand presentation (currently undeveloped).\nIntermediate state and provenance. Intermediate states are im-\nplicit. PPCs are the unnamed outputs of Process and Transfer\nnodes and are consumed directly by subsequent actions. By omit-\nting explicit intermediate item nodes, the design remains compact\nwhile preserving full information and traceability: the provenance\nof any component can be reconstructed via backward traversal of\nthe subgraph rooted at its point of use.\nGlobal axioms and validation. Global invariants include: (i) acyclic-\nity of the top-level action graph; (ii) type safety for all action param-\neters; and (iii) persistence of an item‚Äôs environment association until\nan explicit re-Transfer. Technique references are validated against\na controlled lexicon with defaults and post-conditions. A recipe\nalways yields a single final output but may aggregate multiple PPCs\n(e.g. a main, sauce, and garnish) in its final assembly.\nConcurrency and relative timing. Concurrency is represented na-\ntively by parallel branches that synchronize at explicit merge points.\nThe simplest form of concurrency is the implicit choice of concur-\nrent execution of multiple mutually independent components of a\nrecipe. For example, a recipe may state ‚Äúwhile the cake is baking, we\ncan get started on the buttercream‚Äù. This presents two completely\nseparate execution branches - making a cake, and making butter-\ncream - that eventually merge at the point of icing, in this case.\nTowards an Action-Centric Ontology for Cooking Procedures Using Temporal Graphs\nConcurrent actions on the other hand, such as interleaved steps\nand time-relative interjections (e.g. ‚Äúadd garlic halfway through\nsaut√©ing‚Äù) are modeled via relative-timing fields and sub-processes,\nproviding expressive control over multitasking while respecting the\nDAG‚Äôs partial order. Interjection behaviors are encoded inside node\nsemantics that determine, for example, whether the interjection is\na breaking process (pauses the parent process), or repeating (e.g.\n‚Äúadd cold water every two minutes‚Äù).\nExtensibility and modularity. Actions, and environments refer-\nence external, versioned object definitions (e.g. techniques), allow-\ning new elements to be introduced without altering the core schema.\nRecipes themselves can be embedded as plugin nodes within other\nrecipes, supporting modular construction of complex dishes; for\nexample, a validated ‚Äúpoached egg‚Äù recipe can be inserted as a\nreusable node in a larger breakfast dish.\n4\nConceptual and Feasibility Illustration\nTo qualitatively assess the expressiveness and practical utility of\nthe Recipe Action-Graph DSL, we performed a manual encoding of\na canonical, multi-component dish: the full English breakfast. We\nselected a detailed recipe from a food blog [5] for its rich proce-\ndural structure, heterogeneous tools and environments, multiple\nconcurrent pipelines, and frequent reassignments of PPCs. This\nsetting provides a demanding test of whether the early-stage DSL\ncan faithfully represent real-world cooking logic rather than merely\nstepwise narration. Our effort focuses on how each aspect of this\ndish is captured in the action graph, demonstrating the DSL‚Äôs ability\nto encode complex cooking workflows, synchronize parallel activ-\nities, and preserve all information present in the original instruc-\ntions. Below, we highlight key aspects of the recipe and describe\nthe corresponding constructs in our action graph formalism.\nFigure 2: Visual excerpt describing cooking sausages from\nfull English breakfast recipe action graph\nIn Figure 2, the environment node encodes a (container, location)\ntuple. The ingredient node ‚ÄúSausages [A]‚Äù illustrates per-item iden-\ntity: lettered instance tags disambiguate multiple items sharing a\ncontainer (e.g. sausages [A] and bacon [B]) so they may later be\nreferenced and processed independently. Directed edges labeled\n‚Äúfrom‚Äù (ingredient) and ‚Äúto‚Äù (environment) converge on a Transfer\nnode that records the placement of the sausages from their initial\nenvironment (unassigned/ùúô) into the pan on the stove. Elevating\nthis placement to an explicit Transfer makes the material flow -\noften implicit in textual recipes - concrete and updates the item‚Äôs\nassociated environment for all subsequent actions. The following\nstage is a Process node, where the actual cooking of the sausages\ntakes place. Key features encoded here include:\n‚Ä¢ Temperature Block: The inclusion of a numeric Celsius\nrange (inferred from ‚Äúmedium heat‚Äù + ‚Äúfry‚Äù) reinforces the\nDSL‚Äôs design to translate subjective culinary terminology\ninto precise, machine-interpretable parameters - aided by\nautomated or LLM-supported normalization of temperature\nterms during parsing.\n‚Ä¢ Technique Reference: Pointing to the formal lexicon en-\ntry dry_fry gives unambiguous semantics and reusable\ndefaults. Technique-specific parameters\n(e.g. agitation_frequency=occasional) add controlled\ngranularity while keeping the step tied to a single, well-\ndefined operation with documented pre/post-conditions.\n‚Ä¢ Utensil Block: Declaring a spatula as the manipulating\ntool captures how the item is acted upon, not just what\nis cooked. Tool identity can constrain feasible techniques,\ninfluence geometry (turning/flip actions), and support later\ntargets like robotic execution or capacity checks.\n‚Ä¢ Termination Condition: An outcome-type predicate (‚Äúbrowned\nand cooked through‚Äù) encodes observational endpoints\nalongside (or instead of) fixed durations. These can map\nto sensor-detectable signals or human-observable criteria,\nallowing flexible yet testable completion logic.\nFigure 3: Visual excerpt describing sequential branching\nfrom full English breakfast recipe action graph\nIn the English-breakfast action graph, Figure 3 shows a process\nnode whose output fans out to two successive Transfers. The first\noutgoing edge (labeled from (1)) removes the just-processed PPC\nfrom its current environment (e.g. evacuating a cooked item from\nthe pan). The second outgoing edge (labeled to (2)) introduces a\ndifferent ingredient into that very environment, reusing the freed\nresource. This ordered from ‚Üíto pattern makes environment\noccupancy and sequencing explicit in the DAG: it encodes that the\npan must be vacated before the next item enters, enabling precise\nscheduling, resource contention analysis, and faithful reproduction\nof staging maneuvers like decanting or reserving fat before adding\nnew ingredients. Typical cases include draining off rendered fat or\nfond prior to introducing tomatoes or mushrooms, or sliding toast\ninto the pan immediately after the bacon exits - interdependent\nKumbhakern et al.\ncycles through a shared container that are often only implied in\nprose recipes.\nWe also note current limitations in Transfer semantics. It is\nnot yet formalized whether a transfer targets: (i) a specific PPC\ninstance; (ii) an aggregated set of components; (iii) ‚Äòall residuals‚Äô\nremaining in an environment (e.g. fat, fond); or (iv) a purely logi-\ncal state handoff with no material flow. Likewise, parameters for\nquantity and granularity (whole vs. partial transfer; absolute units\nvs. proportions), and for transfer mode (manual removal, pouring,\nscraping, ladling, draining, tongs/lift) are underspecified. These\nchoices have downstream effects - on provenance, on environment\nstate (what residue remains), and on scheduling (atomicity/locking\nof a shared container). In future iterations, we plan to make these\ndimensions explicit.\nFigure 4: Concurrent process action graph snippet\nFigure 4 deigns to roughly exemplify how a concurrent, relatively\ntimed process would be represented, with the example of adding\nPesto midway through lightly saut√©ing vegetables. In addition, we\ndemonstrate here an aspect of the extensibility architecture, by\nplugging in Pesto as a final product node (hence circular), which\nwould expand if necessary to a pre-existing Pesto recipe.\n5\nComparative Analysis\nWe adopt a hybrid quantitative‚Äìqualitative evaluation to test whether\nthe proposed Action-Graph DSL captures procedural cooking se-\nmantics more faithfully than representative baselines with distinct\naims. We compare against three public formalisms: (i) MILK [10] -\na compact, semantically oriented predicate language; (ii) Corel [9]\n- a modern, author-first DSL emphasizing typed ingredients, time\nand temperature annotations, and validation; and (iii) Culinary\nGrammar (Bagler) [2] - a generative phrase-structure specification\nbuilt from ‚Äúcubits‚Äù (culinary concepts) with rule-based blending. A\npurely quantitative tally risks rewarding authoring conveniences\nover execution semantics; a purely qualitative read risks cherry-\npicking. We therefore combine (i) a feature-by-feature coverage\nrubric and (ii) targeted behavioral probes stressing concurrency, en-\nvironment lineage, interjections/relative timing, and observational\ntermination. Prior characterizations motivate this split: Corel offers\nexplicit time/temperature syntax and checking but omits environ-\nments, transfers, and concurrency; MILK maintains a minimal ac-\ntion set and a container/world model but encodes time/temperature\nas strings and lacks concurrency; Culinary Grammar (Bagler) for-\nmalizes ingredient/quantity/form/process/descriptor/utensil and\nrecursive composition but provides no explicit environment lineage,\nconcurrency, or transfer semantics.\n5.1\nQuantitative rubric and Qualitative Protocol\nWe score each DSL on a 2/1/0 scale - 2 (explicit/first-class), 1 (im-\nplicit/partial), 0 (unsupported) - across a 29-item checklist spanning\nentities/metadata, process/actions, temporal/thermal, graph/control,\nand validation/tooling. Totals are expressed as both raw points and\ncoverage percentage; the denominator (58) reflects the number of\nfeatures evaluated at a 2-point maximum each.\nWe instantiate realistic behaviors and ask what each formal-\nism can natively express: keeping items warm via environmental\nstate; pan reuse and staging via Transfer with residue handling;\noutcome-based termination (e.g. ‚Äúbrowned and cooked through‚Äù);\nand multitasking with interjections (‚Äúadd halfway‚Äù). We judge fi-\ndelity without falling back to untyped prose.\n5.2\nResults\nCoverage. Quantitatively, Action-Graph attains the highest breadth\nof coverage (42/58, 72.4%), followed by MILK (27/58, 46.6%), Culi-\nnary Grammar (Bagler) (25/58, 43.1%), and Corel (18/58, 31.0%).\nBagler‚Äôs score is driven by explicit entities and a typed process lexi-\ncon, plus descriptors that capture outcomes and time expressions; it\nlacks explicit modeling of environment lineage, transfer semantics,\nconcurrency, and provenance.\nBehavioral expressiveness. Corel offers native numeric time and\ntemperature but no relative timing; MILK uses strings/predicates;\nCulinary Grammar (Bagler) encodes durations and qualitative de-\nscriptors (e.g. ‚Äúfor 10 minutes‚Äù, ‚Äúpreheat 220¬∞C‚Äù), but without typed\nramps or relative offsets; Action-Graph adds dedicated fields and\nramps and supports interjections. Neither MILK, Corel, nor Bagler\nincludes a concurrency construct; Action-Graph provides first-class\nconcurrency with merges. MILK has container/location relations\nbut not full lineage; Corel leaves environments in prose; Bagler\nmodels utensils and ‚Äúin X‚Äù prepositional attachment but no explicit\nenvironment modeling or transfer updates; Action-Graph binds\nand updates an item‚Äôs environment on Transfer, enabling staging\nand traceable provenance.\nWhere Action-Graph excels. Our DSL remains the only execution-\nrepresentation DSL, and uniquely operationalizes execution seman-\ntics (state vs. spatial change, environment lineage, partial orders\nTowards an Action-Centric Ontology for Cooking Procedures Using Temporal Graphs\nTable 1: Coverage summary using the 2/1/0 rubric (higher % = broader first-class coverage).\nDSL / Grammar\nExplicit (2)\nImplicit (1)\nMissing (0)\nScore (/58)\nCoverage\nMILK [10]\n9\n9\n11\n27\n46.6%\nCorel [9]\n7\n4\n18\n18\n31.0%\nCulinary Grammar (Bagler) [2]\n9\n7\n13\n25\n43.1%\nAction-Graph (ours)\n19\n4\n6\n42\n72.4%\nNotes. MILK emphasizes a compact predicate set and container/world relations; Corel emphasizes authoring and numerics; Bagler‚Äôs grammar\nformalizes lexical and phrase-structure regularities (cubits; IP/PP/S recursion) with a large corpus; the Action-Graph DSL targets procedural\nfidelity (explicit Process/Transfer/Plate, environments, concurrency, relative timing, temperature ramps, implicit-but-recoverable PPCs).\nwith interjections, temperature profiles, and concurrency) while\nretaining compactness via implicit PPCs.\n6\nFuture Work\nThe Recipe Action-Graph DSL is the terminal representation in a\nthree-stage pipeline that aims to convert natural-language recipes\ninto structured, machine-interpretable, and action-centric ontolo-\ngies and temporal graphs. The DSL specification defines the target\nschema; the end-to-end implementation couples large language\nmodels with classical NLP to populate it.\n(1) Simplification: An LLM performs information-preserving\nrewriting to produce minimal, step-by-step instructions:\nit removes redundancies, clarifies ambiguous references,\nand splits compound clauses into sequential atomic steps -\nwithout dropping semantic content.\n(2) Standardization: A second LLM normalizes entities against\ntwo comprehensive culinary lexicons. Ingredient names are\nmapped to canonical labels; techniques are mapped to stan-\ndardized entries with parameter slots. For example, ‚Äúpour\nfat or juices over (meat) during cooking to keep it moist‚Äù\nis normalized to the technique baste, with parameters for\nagent, target, and frequency.\n(3) Parsing: Domain-adapted NER and structured IE then in-\nstantiate the action graph: ingredients, techniques, tools,\nand temporal markers are detected; Process/Transfer/Plate\nnodes are created with complete parameters, including tech-\nnique references, environment context, temperature pro-\nfiles (with ramps/curves where applicable), and temporal\nconstraints (absolute and relative).\nIn the processing pipeline, an Implicit Step Recovery module is\nintegrated after recipe simplification and standardization but before\nfinal action graph construction. This module is designed to identify\nand reconstruct essential procedural steps that are not explicitly\nstated in the recipe text but are required for correct execution and\ncomplete formalization.\n7\nConclusion\nWe presented a modular, extensible DSL that models recipes as\nstructured action graphs built from three atomic nodes - Process,\nTransfer, and Plate. The design supports implicit state tracking\n(PPCs), explicit environment modeling, and first-class concurrency,\nproviding a robust foundation for capturing the procedural and\ncontextual richness of real-world instructions.\nLooking ahead, we will pair large language models with classi-\ncal NLP to normalize and simplify recipe text, standardize entities,\nrecover implicit steps, and compile graphs. This pipeline bridges in-\nformal, variable prose to machine-interpretable structure, enabling\nculinary knowledge analysis, automated execution, and digital au-\nthoring.\nFuture work includes large-scale extraction, construction of a\ntechnique lexicon (with defaults and postconditions), and system-\natic validation of expressiveness and utility across diverse recipe\ntypes. Advancing this formal modeling aims to catalyze research in\ncomputational gastronomy and intelligent kitchen technologies.\nAcknowledgments\nThis research was supported by the Mphasis AI & Applied Tech\nLab at Ashoka - a collaboration between Ashoka University and\nMphasis Limited.\nReferences\n[1] Rahul Agarwal and Kevin Miller. 2011. Information Extraction from Recipes.\nCS224N Course Project Report. Stanford University. https://nlp.stanford.edu/\ncourses/cs224n/2011/reports/rahul1-kjmiller.pdf\n[2] Ganesh Bagler. 2022. A Generative Grammar of Cooking. doi:10.48550/arXiv.\n2211.09059 arXiv:2211.09059\n[3] Nirav Diwan, Devansh Batra, and Ganesh Bagler. 2020. A Named Entity Based\nApproach to Model Recipes. In 2020 IEEE 36th International Conference on Data\nEngineering Workshops (ICDEW) ‚Äî DECOR Workshop. IEEE, 88‚Äì93. https://arxiv.\norg/abs/2004.12184 Also available as arXiv:2004.12184.\n[4] Jermsak Jermsurawong and Nizar Habash. 2015. Predicting the Structure of\nCooking Recipes. In Proceedings of the 2015 Conference on Empirical Methods in\nNatural Language Processing (EMNLP). Association for Computational Linguistics,\nLisbon, Portugal, 781‚Äì786. doi:10.18653/v1/D15-1090\n[5] Stephanie Le. 2019.\nA Breakdown of the Full English Breakfast.\nhttps:\n//iamafoodblog.com/a-breakdown-of-the-full-english-breakfast/.\nAccessed:\n2024-05-24.\n[6] Shinsuke Mori, Hirokuni Maeta, Yoko Yamakata, and Tetsuro Sasada. 2014.\nFlow Graph Corpus from Recipe Texts. In Proceedings of the Ninth Interna-\ntional Conference on Language Resources and Evaluation (LREC‚Äô14). European\nLanguage Resources Association (ELRA), Reykjavik, Iceland, 2370‚Äì2377. https:\n//aclanthology.org/L14-1594/\n[7] Jens Nevens, Robin de Haes, Rachel Ringe, Mihai Pomarlan, Robert Porzel, Katrien\nBeuls, and Paul van Eecke. 2024. A Benchmark for Recipe Understanding in\nArtificial Agents. In Proceedings of the 2024 Joint International Conference on\nComputational Linguistics, Language Resources and Evaluation (LREC-COLING\n2024), Nicoletta Calzolari, Min-Yen Kan, Veronique Hoste, Alessandro Lenci,\nSakriani Sakti, and Nianwen Xue (Eds.). ELRA and ICCL, Torino, Italia, 22‚Äì42.\nhttps://aclanthology.org/2024.lrec-main.3/\n[8] Dim P. Papadopoulos, Enrique Mora, Nadiia Chepurko, Kuan Wei Huang,\nFerda Ofli, and Antonio Torralba. 2022. Learning Program Representations\nfor Food Images and Cooking Recipes. In Proceedings of the IEEE/CVF Con-\nference on Computer Vision and Pattern Recognition (CVPR). 16559‚Äì16568.\nhttps://openaccess.thecvf.com/content/CVPR2022/papers/Papadopoulos_\nLearning_Program_Representations_for_Food_Images_and_Cooking_\nRecipes_CVPR_2022_paper.pdf\nKumbhakern et al.\n[9] Auke Roorda. 2021. Corel: A DSL for Cooking Recipes. Bachelor‚Äôs Thesis. Univer-\nsity of Groningen, Groningen, The Netherlands. https://fse.studenttheses.ub.\nrug.nl/25731/\n[10] Dan Tasse and Noah A. Smith. 2008. SOUR CREAM: Toward Semantic Processing\nof Recipes. Technical Report CMU-LTI-08-005. Language Technologies Institute,\nCarnegie Mellon University, Pittsburgh, PA. https://homes.cs.washington.edu/\n~nasmith/papers/tasse%2Bsmith.tr08.pdf\n[11] Hao Wang, Guosheng Lin, Steven C. H. Hoi, and Chunyan Miao. 2023. Learning\nStructural Representations for Recipe Generation and Food Retrieval. IEEE\nTransactions on Pattern Analysis and Machine Intelligence 45, 3 (2023), 3363‚Äì3377.\ndoi:10.1109/TPAMI.2022.3181294\n",
    "content": "# Paper Summary and Analysis: *Towards an Action-Centric Ontology for Cooking Procedures Using Temporal Graphs*\n\n---\n\n## 1. Core Content and Key Contributions\n\nThis paper proposes a formal modeling approach for cooking procedures based on an **Action Graph**, aiming to address the complexity and ambiguity in the automation, understanding, and execution of cooking processes. The central idea is to model cooking workflows as a **Directed Acyclic Graph (DAG)** containing three fundamental action types: **Process** (transformation), **Transfer** (spatial movement), and **Plate** (presentation), representing state changes, spatial transitions, and final output, respectively.\n\n### Key Contributions:\n\n1. **Proposed a structured, extensible Domain-Specific Language (DSL) for Cooking Action Graphs**, capable of precisely representing state changes, concurrent operations, environmental changes, and spatial manipulations in cooking.\n2. **Formalized the semantic structure of cooking processes**, including environments (e.g., pots, ovens), tools, temperature, time parameters, and implicit yet traceable representations of intermediate products (PPC, Partially Processed Components).\n3. **Supports concurrency and relative time control**, such as \"add garlic halfway through saut√©ing,\" using graph structures to model concurrent steps.\n4. **Validated the DSL through manual encoding of a complete British breakfast recipe**, demonstrating its expressive power in real-world complex cooking workflows.\n5. **Proposed a three-stage natural language to action graph conversion pipeline**, including simplification, normalization, and parsing, laying the groundwork for future automated parsing.\n\n---\n\n## 2. Innovations and Breakthroughs\n\nThis paper introduces several innovations in the modeling of cooking procedures:\n\n### (1) **Action-Centric Ontology Design**\n- Moves beyond treating cooking as a linear list of actions, instead centering on the **Action Graph**, emphasizing state transitions, environmental dependencies, and concurrency among actions.\n- Introduces three basic action node types: **Process**, **Transfer**, and **Plate**, each corresponding to physical state changes, spatial movement, and final presentation, with high composability.\n\n### (2) **Implicit but Traceable Intermediate Product Mechanism**\n- Introduces the concept of **PPC (Partially Processed Components)** as implicit outputs of action nodes, avoiding excessive complexity in the graph.\n- Achieves **full traceability through graph backtracking**, ensuring information completeness while maintaining graph simplicity.\n\n### (3) **Concurrency and Relative Time Modeling**\n- Supports **concurrent operations** (e.g., saut√©ing and preparing sauce simultaneously) and **relative time insertions** (e.g., \"add garlic halfway\").\n- Uses **graph branching and merging mechanisms**, combined with time constraint fields, to structurally model concurrency and interpolation.\n\n### (4) **Environmental Modeling and Spatial Operations**\n- Each item (ingredient or intermediate product) is associated with an **environmental state** (container, location, geometric pose), enabling spatial operations (e.g., tilting a pan to control ingredient distribution).\n- Enables **explicit modeling and dynamic updating of environmental states**, providing a foundation for automation (e.g., robotic cooking).\n\n### (5) **Extensibility and Modularity**\n- Elements such as actions, environments, and tools reference external defined objects (e.g., technical dictionaries), supporting **versioning and extension**.\n- Recipes can be **nested as plugin nodes** within other recipes, supporting modular construction of complex dishes.\n\n---\n\n## 3. Startup Project Suggestions\n\nBased on the formalized cooking action graph and DSL design proposed in this paper, several commercially viable startup directions can be explored:\n\n### (1) **Intelligent Recipe Parsing and Automated Execution System**\n\n**Project Description:**\nDevelop an intelligent recipe system based on natural language understanding and action graph modeling, capable of automatically converting user-input recipes into structured action graphs and further driving **home or commercial kitchen robots** to execute cooking tasks.\n\n**Core Technologies:**\n- **Natural Language Processing (NLP)** + **Large Language Models (LLMs)** for recipe text simplification and normalization.\n- **DSL parser** to convert text into action graphs.\n- Integration with **kitchen robots or smart appliances** for automated execution.\n\n**Application Scenarios:**\n- Home smart kitchen assistants\n- Commercial kitchen automation systems\n- Health-focused meal customization platforms\n\n---\n\n### (2) **Cooking Process Simulation and Teaching Platform**\n\n**Project Description:**\nBuild a virtual cooking simulation platform where users can upload or select recipes, and the system converts them into visual action graphs, simulating the entire cooking process for teaching, training, or recipe validation.\n\n**Core Technologies:**\n- **Action graph visualization engine**\n- **Time and concurrency simulator**\n- **User interaction and feedback system**\n\n**Application Scenarios:**\n- Cooking education platforms\n- Chef training systems\n- Recipe optimization and validation tools\n\n---\n\n### (3) **Cooking Knowledge Graph and Recommendation Engine**\n\n**Project Description:**\nBuild a **cooking knowledge graph** based on action graphs, structuring ingredients, techniques, tools, and environments, supporting intelligent recommendations based on procedural logic (e.g., \"ingredient substitution\", \"simplified steps\", \"healthier modifications\").\n\n**Core Technologies:**\n- **Action graph database construction**\n- **Graph Neural Networks (GNNs)** for recommendation and reasoning\n- **User behavior modeling and personalized recommendation**\n\n**Application Scenarios:**\n- Ingredient substitution recommendation\n- Cooking difficulty adaptation\n- Healthy diet optimization\n\n---\n\n### (4) **Modular Smart Recipe Editor**\n\n**Project Description:**\nDevelop a **DSL recipe editor** for chefs and content creators, supporting graphical editing of action graphs, real-time logic validation, and export to structured formats for further processing (e.g., robot execution, teaching simulation).\n\n**Core Technologies:**\n- **Graphical DSL editor**\n- **Real-time semantic validation and error feedback**\n- Export to multiple formats (JSON, XML, visual graphs, etc.)\n\n**Application Scenarios:**\n- Smart recipe management for professional chefs\n- Efficient content creation tools for food content creators\n- Course content development platforms for educational institutions\n\n---\n\n## Conclusion\n\nThis paper presents a clear, semantically rich, and extensible framework for formal modeling of cooking processes. It not only advances the field of **Computational Gastronomy**, but also lays a solid technical foundation for **smart kitchen systems**, **automated cooking**, and **culinary education**. Around the proposed action graph DSL, numerous commercially valuable innovation projects can be developed, particularly suitable for startup teams integrating AI, robotics, and smart hardware.",
    "github": "",
    "hf": ""
}